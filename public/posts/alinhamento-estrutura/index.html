<!doctype html><html lang=pt dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Alinhamento, Preenchimento e Empacotamento de Estruturas de Dados | danieltak</title>
<meta name=keywords content="C++,Estrutura,struct"><meta name=description content="Alignment, padding and packing."><meta name=author content="danieltak"><link rel=canonical href=https://danieltak.com.br/posts/alinhamento-estrutura/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=https://danieltak.com.br/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=16x16 href=https://danieltak.com.br/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://danieltak.com.br/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://danieltak.com.br/%3Clink%20/%20abs%20url%3E><link rel=mask-icon href=https://danieltak.com.br/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Alinhamento, Preenchimento e Empacotamento de Estruturas de Dados"><meta property="og:description" content="Alignment, padding and packing."><meta property="og:type" content="article"><meta property="og:url" content="https://danieltak.com.br/posts/alinhamento-estrutura/"><meta property="og:image" content="https://danieltak.com.br/%3Cimage%20path/url%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-02-06T21:11:32-03:00"><meta property="article:modified_time" content="2024-02-06T21:11:32-03:00"><meta property="og:site_name" content="danieltak"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://danieltak.com.br/%3Cimage%20path/url%3E"><meta name=twitter:title content="Alinhamento, Preenchimento e Empacotamento de Estruturas de Dados"><meta name=twitter:description content="Alignment, padding and packing."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://danieltak.com.br/posts/"},{"@type":"ListItem","position":2,"name":"Alinhamento, Preenchimento e Empacotamento de Estruturas de Dados","item":"https://danieltak.com.br/posts/alinhamento-estrutura/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Alinhamento, Preenchimento e Empacotamento de Estruturas de Dados","name":"Alinhamento, Preenchimento e Empacotamento de Estruturas de Dados","description":"Alignment, padding and packing.","keywords":["C++","Estrutura","struct"],"articleBody":"O que é? O alinhamento de estruturas de dados é a forma que um dado é organizado e acessado na memória do computador. E pode ser organizado em três temas:\nData alignment - alinhamento de dados Data structure padding - preenchimento da estrutura de dados Data structure packing - empacotamento da estrutura de dados Alinhamento Na maioria dos cenários, você nunca precisa se preocupar com o alinhamento porque o alinhamento padrão já é ideal. Mas ao trabalhar com baixo nível e sistemas embarcados, frequentemente irá se deparar com este assunto.\nFunção alignof Para obter o alinhamento, em bytes, o operador alignof() pode ser usado.\nA seguinte estrutura possui um alinhamento de 4 bytes e será explicado na sessão Preenchimento.\n#include struct TestStructure { char AA; int BB; char CC; }; int main() { struct TestStructure test; std::cout \u003c\u003c \"Size of TestStructure alignment: \" \u003c\u003c alignof(test) \u003c\u003c std::endl; } Função alignas Para especificar o alinhamento de uma estrutura o especificador alignas() pode ser usado.\n#include struct alignas(8) MyAlignedStructure {}; struct TestStructure { char AA; int BB; char CC; }; int main() { struct TestStructure test; struct MyAlignedStructure testAlignedAs; std::cout \u003c\u003c \"Size of TestStructure alignment: \" \u003c\u003c alignof(test) \u003c\u003c std::endl; std::cout \u003c\u003c \"Size of MyAlignedStructure alignment: \" \u003c\u003c alignof(testAlignedAs) \u003c\u003c std::endl; } Resultado:\nSize of TestStructure alignment: 4\rSize of MyAlignedStructure alignment: 8 Quando múltiplos alignas são aplicados à mesma declaração, aquele com o maior valor é usado. Um alignas valor de 0 é ignorado.\n#include struct alignas(8) alignas(16) MyAlignedStructure {}; struct TestStructure { char AA; int BB; char CC; }; union alignas(0) U1 { int i; float f; }; union U2 { int i; float f; }; int main() { struct TestStructure test; struct MyAlignedStructure testAlignedAs; union U1 firstUnion; union U2 secondUnion; std::cout \u003c\u003c \"Size of TestStructure alignment: \" \u003c\u003c alignof(test) \u003c\u003c std::endl; std::cout \u003c\u003c \"Size of MyAlignedStructure alignment: \" \u003c\u003c alignof(testAlignedAs) \u003c\u003c std::endl; std::cout \u003c\u003c \"Size of firstUnion alignment: \" \u003c\u003c alignof(firstUnion) \u003c\u003c std::endl; std::cout \u003c\u003c \"Size of secondUnion alignment: \" \u003c\u003c alignof(secondUnion) \u003c\u003c std::endl; } Resultado:\nSize of TestStructure alignment: 4\rSize of MyAlignedStructure alignment: 16\rSize of firstUnion alignment: 4\rSize of secondUnion alignment: 4 Você pode fornecer um tipo como o valor de alinhamento. O alinhamento padrão do tipo é usado como o valor de alinhamento.\n#include union alignas(long) U1 { int i; float f; }; union U2 { int i; float f; }; int main() { union U1 firstUnion; union U2 secondUnion; std::cout \u003c\u003c \"Size of firstUnion alignment: \" \u003c\u003c alignof(firstUnion) \u003c\u003c std::endl; std::cout \u003c\u003c \"Size of secondUnion alignment: \" \u003c\u003c alignof(secondUnion) \u003c\u003c std::endl; } Resultado:\nSize of firstUnion alignment: 8\rSize of secondUnion alignment: 4 Um pacote de parâmetros de modelo (alignas (pack...)) pode ser usado para o valor de alinhamento. O maior valor de alinhamento de todos os elementos da embalagem é usado.\n#include template \u003ctypename... Ts\u003e class alignas(Ts...) C2 { char c; }; int main() { C2\u003c\u003e c1; C2\u003cshort, int\u003e c4; C2\u003cint, float, double\u003e c8; std::cout \u003c\u003c \"Size of c1 alignment: \" \u003c\u003c alignof(c1) \u003c\u003c std::endl; std::cout \u003c\u003c \"Size of c4 alignment: \" \u003c\u003c alignof(c4) \u003c\u003c std::endl; std::cout \u003c\u003c \"Size of c8 alignment: \" \u003c\u003c alignof(c8) \u003c\u003c std::endl; return 0; } Resultado:\nSize of c1 alignment: 1\rSize of c4 alignment: 4\rSize of c8 alignment: 8 Preenchimento A maioria dos compiladores, quando você declara um struct, insere preenchimento entre os membros para garantir que eles sejam alinhados aos endereços apropriados na memória (geralmente um múltiplo do tamanho do tipo). Isso evita a penalidade de desempenho (ou erro total) em algumas arquiteturas associadas ao acesso a variáveis que não estão alinhadas corretamente.\nNo exemplo abaixo, temos duas variáveis do tipo char, AA e CC, e uma do tipo int, nomeada BB.\n#include struct TestStructure { char AA; int BB; char CC; }; int main() { struct TestStructure test; std::cout \u003c\u003c \"Size of char:\" \u003c\u003c \" \" \u003c\u003c sizeof(test.AA) \u003c\u003c std::endl; std::cout \u003c\u003c \"Size of int:\" \u003c\u003c \" \" \u003c\u003c sizeof(test.BB) \u003c\u003c std::endl; std::cout \u003c\u003c \"Size of char:\" \u003c\u003c \" \" \u003c\u003c sizeof(test.CC) \u003c\u003c std::endl; } O tamanho individual de cada variável foi obitda com a função sizeof() e a seguinte saída:\nSize of char: 1\rSize of int: 4\rSize of char: 1 Qual é o tamanho da struct?\nIntuitivamente falamos que seria a soma das variáveis da estrutura, ou seja, 6 bytes.\nPorém, essa afirmação está errada e usando a função sizeof(), verificamos que o tamanho da estrutura é de 12 bytes!\nIsso ocorre por causa do preenchimento (padding), conforme ilustrado abaixo:\n| 1 | 2 | 3 | 4 |\r| AA(1) | pad.................. | // 1 byte + 3 bytes pad\r| BB(1) | BB(2) | BB(3) | BB(4) | // 4 bytes\r| CC(1) | pad.................. | // 1 byte + 3 bytes pad A variável AA ocupa 4 bytes, sendo 1 byte a variável e 3 bytes de preenchimento.\n#pragma pack O #pragma pack instrui o compilador a empacotar os membros da estrutura com um alinhamento específico. A maioria dos compiladores, quando você declara um struct, insere preenchimento entre os membros para garantir que eles sejam alinhados aos endereços apropriados na memória (geralmente um múltiplo do tamanho do tipo de dado).\nEntão ao especificar #pragma pack(1), o alinhamento é de 1 byte para todos os membros do escopo daquela definição. Menos para as struturas que forem sobrescritas com alignas() ou outra forma de alterar o alinhamento.\n#include #pragma pack(1) struct alignas(2) MyAlignedStructure {}; struct TestStructure { char AA; int BB; char CC; }; int main() { struct TestStructure test; struct MyAlignedStructure testAlignedAs; std::cout \u003c\u003c \"Size of TestStructure alignment: \" \u003c\u003c alignof(test) \u003c\u003c std::endl; std::cout \u003c\u003c \"Size of MyAlignedStructure alignment: \" \u003c\u003c alignof(testAlignedAs) \u003c\u003c std::endl; std::cout \u003c\u003c \"Size of testAlignedAs struct:\" \u003c\u003c \" \" \u003c\u003c sizeof(testAlignedAs) \u003c\u003c std::endl; std::cout \u003c\u003c \"Size of test struct:\" \u003c\u003c \" \" \u003c\u003c sizeof(test) \u003c\u003c std::endl; } Resultado:\nSize of TestStructure alignment: 1\rSize of MyAlignedStructure alignment: 2\rSize of testAlignedAs struct: 2\rSize of test struct: 6 Então com o alinhamento de 1 byte, o tamanho da estrutura é a soma de seus membros.\nE ao utilizar um alinhamento de 2 bytes?\n#include #pragma pack(2) struct alignas(2) MyAlignedStructure {}; struct TestStructure { char AA; int BB; char CC; }; int main() { struct TestStructure test; struct MyAlignedStructure testAlignedAs; std::cout \u003c\u003c \"Size of TestStructure alignment: \" \u003c\u003c alignof(test) \u003c\u003c std::endl; std::cout \u003c\u003c \"Size of MyAlignedStructure alignment: \" \u003c\u003c alignof(testAlignedAs) \u003c\u003c std::endl; std::cout \u003c\u003c \"Size of testAlignedAs struct:\" \u003c\u003c \" \" \u003c\u003c sizeof(testAlignedAs) \u003c\u003c std::endl; std::cout \u003c\u003c \"Size of test struct:\" \u003c\u003c \" \" \u003c\u003c sizeof(test) \u003c\u003c std::endl; } Resultado:\nSize of TestStructure alignment: 2\rSize of MyAlignedStructure alignment: 2\rSize of testAlignedAs struct: 2\rSize of test struct: 8 Então a estrutura é empacotada da seguinte forma:\n| 1 | 2 |\r| AA(1) | pad.. | // 1 byte + 1 byte pad\r| BB(1) | BB(2) | // 2 bytes\r| BB(3) | BB(4) | // 2 bytes\r| CC(1) | pad.. | // 1 byte + 1 byte pad Problema O artigo “Anybody who writes #pragma pack(1) may as well just wear a sign on their forehead that says “I hate RISC”” explica os riscos de usar o #pragma pack(1).\nIsso é verdade em sistemas desktop, porém em sistemas embarcados, nem tanto…\nEm muitos casos o gargalo não está no processamento, mas em outros locais, como a comunicação. Então a perda de desempenho na otimização do processamento se torna aceitável, ao ganhar mais espaço para criar um pacote de dados e evitar os preenchimentos, ou até mesmo para dar compatibilidade entre dispositivos diferentes.\nPortanto, cada caso deve ser analisado e não existem dogmas.\nOpinião Não utilizar as diretivas de compilador #pragma, pois ela é dependente do compilador utilizado. A maioria dos compiladores possuem suporte e um comportamento similar, mas em raros casos isso não é verdade. E é bem quando você precisar entregar o projeto atrasado, que a nova versão de um compilador pode quebrar tudo.\nEsse tipo de abordagem é muito utilizado por programador de C ou programadores muito experientes acostumados com o C++ 98.\nO recomendado é se manter no STL do C++ e usar as funções padrões fornecidas e testadas pelo mundo inteiro.\nMas nos casos em que é necessário usar o pragma pack, opte por usar o push e o pop.\nAprofundamento A principal referência é o The Lost Art of Structure Packing, um guia em inglês que aborda em outras linguagens de programação.\nTambém é possível usar as diretivas #pragma pack(push, n) e #pragma pack(pop).\nUm artigo no Geek for Geeks é sempre recomendado.\nReferências Alinhamento - Microsoft C++ Structure padding and packing The Lost Art of Structure Packing alignof() - Cpp Reference alignas() - Cpp Reference #pragma pack effect Anybody who writes #pragma pack(1) may as well just wear a sign on their forehead that says “I hate RISC” Structure Member Alignment, Padding and Data Packing ","wordCount":"1489","inLanguage":"pt","image":"https://danieltak.com.br/%3Cimage%20path/url%3E","datePublished":"2024-02-06T21:11:32-03:00","dateModified":"2024-02-06T21:11:32-03:00","author":{"@type":"Person","name":"danieltak"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://danieltak.com.br/posts/alinhamento-estrutura/"},"publisher":{"@type":"Organization","name":"danieltak","logo":{"@type":"ImageObject","url":"https://danieltak.com.br/%3Clink%20/%20abs%20url%3E"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://danieltak.com.br accesskey=h title="Home (Alt + H)"><img src=https://danieltak.com.br/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://danieltak.com.br/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://danieltak.com.br/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://danieltak.com.br>Início</a>&nbsp;»&nbsp;<a href=https://danieltak.com.br/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Alinhamento, Preenchimento e Empacotamento de Estruturas de Dados</h1><div class=post-description>Alignment, padding and packing.</div><div class=post-meta><span title='2024-02-06 21:11:32 -0300 -03'>6 fev. 2024</span>&nbsp;·&nbsp;7 minutos&nbsp;·&nbsp;1489 palavras&nbsp;·&nbsp;danieltak&nbsp;|&nbsp;<a href=https://github.com/danieltak/danieltak-blog/blob/master/content/posts/alinhamento-estrutura.md/posts/alinhamento-estrutura.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Conteúdo</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#o-que-é>O que é?</a></li><li><a href=#alinhamento>Alinhamento</a><ul><li><a href=#função-alignof>Função alignof</a></li><li><a href=#função-alignas>Função alignas</a></li></ul></li><li><a href=#preenchimento>Preenchimento</a></li><li><a href=#pragma-pack>#pragma pack</a><ul><li><a href=#problema>Problema</a></li><li><a href=#opinião>Opinião</a></li></ul></li><li><a href=#aprofundamento>Aprofundamento</a></li><li><a href=#referências>Referências</a></li></ul></nav></div></details></div><div class=post-content><h2 id=o-que-é>O que é?<a hidden class=anchor aria-hidden=true href=#o-que-é>#</a></h2><p>O <a href="https://learn.microsoft.com/pt-br/cpp/cpp/alignment-cpp-declarations?view=msvc-170">alinhamento</a> de estruturas de dados é a forma que um dado é organizado e acessado na memória do computador. E pode ser organizado em três temas:</p><ul><li>Data alignment - alinhamento de dados</li><li>Data structure padding - preenchimento da estrutura de dados</li><li>Data structure packing - empacotamento da estrutura de dados</li></ul><h2 id=alinhamento>Alinhamento<a hidden class=anchor aria-hidden=true href=#alinhamento>#</a></h2><p>Na maioria dos cenários, você nunca precisa se preocupar com o alinhamento porque o alinhamento padrão já é ideal. Mas ao trabalhar com baixo nível e sistemas embarcados, frequentemente irá se deparar com este assunto.</p><h3 id=função-alignof>Função alignof<a hidden class=anchor aria-hidden=true href=#função-alignof>#</a></h3><p>Para obter o alinhamento, em bytes, o operador <a href=https://en.cppreference.com/w/cpp/language/alignof>alignof()</a> pode ser usado.</p><p>A seguinte estrutura possui um alinhamento de 4 bytes e será explicado na sessão <a href=#preenchimento>Preenchimento</a>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>TestStructure</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=kt>char</span> <span class=n>AA</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   <span class=kt>int</span> <span class=n>BB</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   <span class=kt>char</span> <span class=n>CC</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>TestStructure</span> <span class=n>test</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Size of TestStructure alignment: &#34;</span> <span class=o>&lt;&lt;</span> <span class=k>alignof</span><span class=p>(</span><span class=n>test</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h3 id=função-alignas>Função alignas<a hidden class=anchor aria-hidden=true href=#função-alignas>#</a></h3><p>Para especificar o alinhamento de uma estrutura o especificador <a href=https://en.cppreference.com/w/cpp/language/alignas>alignas()</a> pode ser usado.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nf>alignas</span><span class=p>(</span><span class=mi>8</span><span class=p>)</span> <span class=n>MyAlignedStructure</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>TestStructure</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=kt>char</span> <span class=n>AA</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   <span class=kt>int</span> <span class=n>BB</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   <span class=kt>char</span> <span class=n>CC</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>TestStructure</span> <span class=n>test</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>MyAlignedStructure</span> <span class=n>testAlignedAs</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Size of TestStructure alignment: &#34;</span> <span class=o>&lt;&lt;</span> <span class=k>alignof</span><span class=p>(</span><span class=n>test</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Size of MyAlignedStructure alignment: &#34;</span> <span class=o>&lt;&lt;</span> <span class=k>alignof</span><span class=p>(</span><span class=n>testAlignedAs</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Resultado:</p><pre tabindex=0><code>Size of TestStructure alignment: 4
Size of MyAlignedStructure alignment: 8
</code></pre><p>Quando múltiplos alignas são aplicados à mesma declaração, aquele com o maior valor é usado. Um alignas valor de 0 é ignorado.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nf>alignas</span><span class=p>(</span><span class=mi>8</span><span class=p>)</span> <span class=k>alignas</span><span class=p>(</span><span class=mi>16</span><span class=p>)</span> <span class=n>MyAlignedStructure</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>TestStructure</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=kt>char</span> <span class=n>AA</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   <span class=kt>int</span> <span class=n>BB</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   <span class=kt>char</span> <span class=n>CC</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>union</span> <span class=nf>alignas</span><span class=p>(</span><span class=mi>0</span><span class=p>)</span> <span class=n>U1</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>f</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>union</span> <span class=nc>U2</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>f</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>TestStructure</span> <span class=n>test</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>MyAlignedStructure</span> <span class=n>testAlignedAs</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>union</span> <span class=nc>U1</span> <span class=n>firstUnion</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>union</span> <span class=nc>U2</span> <span class=n>secondUnion</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Size of TestStructure alignment: &#34;</span> <span class=o>&lt;&lt;</span> <span class=k>alignof</span><span class=p>(</span><span class=n>test</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Size of MyAlignedStructure alignment: &#34;</span> <span class=o>&lt;&lt;</span> <span class=k>alignof</span><span class=p>(</span><span class=n>testAlignedAs</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Size of firstUnion alignment: &#34;</span> <span class=o>&lt;&lt;</span> <span class=k>alignof</span><span class=p>(</span><span class=n>firstUnion</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Size of secondUnion alignment: &#34;</span> <span class=o>&lt;&lt;</span> <span class=k>alignof</span><span class=p>(</span><span class=n>secondUnion</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Resultado:</p><pre tabindex=0><code>Size of TestStructure alignment: 4
Size of MyAlignedStructure alignment: 16
Size of firstUnion alignment: 4
Size of secondUnion alignment: 4
</code></pre><p>Você pode fornecer um tipo como o valor de alinhamento. O alinhamento padrão do tipo é usado como o valor de alinhamento.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>union</span> <span class=nf>alignas</span><span class=p>(</span><span class=kt>long</span><span class=p>)</span> <span class=n>U1</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>f</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>union</span> <span class=nc>U2</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>int</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=kt>float</span> <span class=n>f</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>union</span> <span class=nc>U1</span> <span class=n>firstUnion</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>union</span> <span class=nc>U2</span> <span class=n>secondUnion</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Size of firstUnion alignment: &#34;</span> <span class=o>&lt;&lt;</span> <span class=k>alignof</span><span class=p>(</span><span class=n>firstUnion</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Size of secondUnion alignment: &#34;</span> <span class=o>&lt;&lt;</span> <span class=k>alignof</span><span class=p>(</span><span class=n>secondUnion</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Resultado:</p><pre tabindex=0><code>Size of firstUnion alignment: 8
Size of secondUnion alignment: 4
</code></pre><p>Um pacote de parâmetros de modelo <code>(alignas (pack...))</code> pode ser usado para o valor de alinhamento. O maior valor de alinhamento de todos os elementos da embalagem é usado.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>template</span> <span class=o>&lt;</span><span class=k>typename</span><span class=p>...</span> <span class=n>Ts</span><span class=o>&gt;</span>
</span></span><span class=line><span class=cl><span class=k>class</span> <span class=nc>alignas</span><span class=p>(</span><span class=n>Ts</span><span class=p>...)</span> <span class=n>C2</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kt>char</span> <span class=n>c</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>C2</span><span class=o>&lt;&gt;</span> <span class=n>c1</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>C2</span><span class=o>&lt;</span><span class=kt>short</span><span class=p>,</span> <span class=kt>int</span><span class=o>&gt;</span> <span class=n>c4</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>C2</span><span class=o>&lt;</span><span class=kt>int</span><span class=p>,</span> <span class=kt>float</span><span class=p>,</span> <span class=kt>double</span><span class=o>&gt;</span> <span class=n>c8</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Size of c1 alignment: &#34;</span> <span class=o>&lt;&lt;</span> <span class=k>alignof</span><span class=p>(</span><span class=n>c1</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Size of c4 alignment: &#34;</span> <span class=o>&lt;&lt;</span> <span class=k>alignof</span><span class=p>(</span><span class=n>c4</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Size of c8 alignment: &#34;</span> <span class=o>&lt;&lt;</span> <span class=k>alignof</span><span class=p>(</span><span class=n>c8</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Resultado:</p><pre tabindex=0><code>Size of c1 alignment: 1
Size of c4 alignment: 4
Size of c8 alignment: 8
</code></pre><h2 id=preenchimento>Preenchimento<a hidden class=anchor aria-hidden=true href=#preenchimento>#</a></h2><p>A maioria dos compiladores, quando você declara um <code>struct</code>, insere preenchimento entre os membros para garantir que eles sejam alinhados aos endereços apropriados na memória (geralmente um múltiplo do tamanho do tipo). Isso evita a penalidade de desempenho (ou erro total) em algumas arquiteturas associadas ao acesso a variáveis que não estão alinhadas corretamente.</p><p>No exemplo abaixo, temos duas variáveis do tipo <code>char</code>, <code>AA</code> e <code>CC</code>, e uma do tipo <code>int</code>, nomeada <code>BB</code>.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp></span>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>TestStructure</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=kt>char</span> <span class=n>AA</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   <span class=kt>int</span> <span class=n>BB</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   <span class=kt>char</span> <span class=n>CC</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>TestStructure</span> <span class=n>test</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Size of char:&#34;</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span> <span class=o>&lt;&lt;</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>test</span><span class=p>.</span><span class=n>AA</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Size of int:&#34;</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span> <span class=o>&lt;&lt;</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>test</span><span class=p>.</span><span class=n>BB</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Size of char:&#34;</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span> <span class=o>&lt;&lt;</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>test</span><span class=p>.</span><span class=n>CC</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>O tamanho individual de cada variável foi obitda com a função <code>sizeof()</code> e a seguinte saída:</p><pre tabindex=0><code>Size of char: 1
Size of int: 4
Size of char: 1
</code></pre><blockquote><p>Qual é o tamanho da struct?</p></blockquote><p>Intuitivamente falamos que seria a soma das variáveis da estrutura, ou seja, 6 bytes.</p><p>Porém, essa afirmação está errada e usando a função <code>sizeof()</code>, verificamos que o tamanho da estrutura é de 12 bytes!</p><p>Isso ocorre por causa do preenchimento (padding), conforme ilustrado abaixo:</p><pre tabindex=0><code>|   1   |   2   |   3   |   4   |
| AA(1) | pad.................. |  // 1 byte + 3 bytes pad
| BB(1) | BB(2) | BB(3) | BB(4) |  // 4 bytes
| CC(1) | pad.................. |  // 1 byte + 3 bytes pad
</code></pre><p>A variável AA ocupa 4 bytes, sendo 1 byte a variável e 3 bytes de preenchimento.</p><h2 id=pragma-pack>#pragma pack<a hidden class=anchor aria-hidden=true href=#pragma-pack>#</a></h2><p>O <a href=https://stackoverflow.com/questions/3318410/pragma-pack-effect>#pragma pack</a> instrui o compilador a empacotar os membros da estrutura com um alinhamento específico. A maioria dos compiladores, quando você declara um struct, insere preenchimento entre os membros para garantir que eles sejam alinhados aos endereços apropriados na memória (geralmente um múltiplo do tamanho do tipo de dado).</p><p>Então ao especificar <code>#pragma pack(1)</code>, o alinhamento é de 1 byte para todos os membros do escopo daquela definição. Menos para as struturas que forem sobrescritas com <code>alignas()</code> ou outra forma de alterar o alinhamento.</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#pragma pack(1)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>struct</span> <span class=nf>alignas</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>  <span class=n>MyAlignedStructure</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>TestStructure</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=kt>char</span> <span class=n>AA</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   <span class=kt>int</span> <span class=n>BB</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   <span class=kt>char</span> <span class=n>CC</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>TestStructure</span> <span class=n>test</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>MyAlignedStructure</span> <span class=n>testAlignedAs</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Size of TestStructure alignment: &#34;</span> <span class=o>&lt;&lt;</span> <span class=k>alignof</span><span class=p>(</span><span class=n>test</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Size of MyAlignedStructure alignment: &#34;</span> <span class=o>&lt;&lt;</span> <span class=k>alignof</span><span class=p>(</span><span class=n>testAlignedAs</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Size of testAlignedAs struct:&#34;</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span> <span class=o>&lt;&lt;</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>testAlignedAs</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Size of test struct:&#34;</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span> <span class=o>&lt;&lt;</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>test</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Resultado:</p><pre tabindex=0><code>Size of TestStructure alignment: 1
Size of MyAlignedStructure alignment: 2
Size of testAlignedAs struct: 2
Size of test struct: 6
</code></pre><p>Então com o alinhamento de 1 byte, o tamanho da estrutura é a soma de seus membros.</p><blockquote><p>E ao utilizar um alinhamento de 2 bytes?</p></blockquote><div class=highlight><pre tabindex=0 class=chroma><code class=language-cpp data-lang=cpp><span class=line><span class=cl><span class=cp>#include</span> <span class=cpf>&lt;iostream&gt;</span><span class=cp>
</span></span></span><span class=line><span class=cl><span class=cp>#pragma pack(2)
</span></span></span><span class=line><span class=cl><span class=cp></span><span class=k>struct</span> <span class=nf>alignas</span><span class=p>(</span><span class=mi>2</span><span class=p>)</span>  <span class=n>MyAlignedStructure</span> <span class=p>{};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>struct</span> <span class=nc>TestStructure</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>   <span class=kt>char</span> <span class=n>AA</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   <span class=kt>int</span> <span class=n>BB</span><span class=p>;</span>
</span></span><span class=line><span class=cl>   <span class=kt>char</span> <span class=n>CC</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>};</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>TestStructure</span> <span class=n>test</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=k>struct</span> <span class=nc>MyAlignedStructure</span> <span class=n>testAlignedAs</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Size of TestStructure alignment: &#34;</span> <span class=o>&lt;&lt;</span> <span class=k>alignof</span><span class=p>(</span><span class=n>test</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Size of MyAlignedStructure alignment: &#34;</span> <span class=o>&lt;&lt;</span> <span class=k>alignof</span><span class=p>(</span><span class=n>testAlignedAs</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Size of testAlignedAs struct:&#34;</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span> <span class=o>&lt;&lt;</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>testAlignedAs</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl>    <span class=n>std</span><span class=o>::</span><span class=n>cout</span> <span class=o>&lt;&lt;</span> <span class=s>&#34;Size of test struct:&#34;</span> <span class=o>&lt;&lt;</span> <span class=s>&#34; &#34;</span> <span class=o>&lt;&lt;</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>test</span><span class=p>)</span> <span class=o>&lt;&lt;</span> <span class=n>std</span><span class=o>::</span><span class=n>endl</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>Resultado:</p><pre tabindex=0><code>Size of TestStructure alignment: 2
Size of MyAlignedStructure alignment: 2
Size of testAlignedAs struct: 2
Size of test struct: 8
</code></pre><p>Então a estrutura é empacotada da seguinte forma:</p><pre tabindex=0><code>|   1   |   2   |
| AA(1) | pad.. |  // 1 byte + 1 byte pad
| BB(1) | BB(2) |  // 2 bytes
| BB(3) | BB(4) |  // 2 bytes
| CC(1) | pad.. |  // 1 byte + 1 byte pad
</code></pre><h3 id=problema>Problema<a hidden class=anchor aria-hidden=true href=#problema>#</a></h3><p>O <a href="https://devblogs.microsoft.com/oldnewthing/20200103-00/?p=103290">artigo </a>&ldquo;Anybody who writes #pragma pack(1) may as well just wear a sign on their forehead that says “I hate RISC”&rdquo; explica os riscos de usar o <code>#pragma pack(1)</code>.</p><p>Isso é verdade em sistemas desktop, porém em sistemas embarcados, nem tanto&mldr;</p><p>Em muitos casos o gargalo não está no processamento, mas em outros locais, como a comunicação. Então a perda de desempenho na otimização do processamento se torna aceitável, ao ganhar mais espaço para criar um pacote de dados e evitar os preenchimentos, ou até mesmo para dar compatibilidade entre dispositivos diferentes.</p><p>Portanto, cada caso deve ser analisado e não existem dogmas.</p><h3 id=opinião>Opinião<a hidden class=anchor aria-hidden=true href=#opinião>#</a></h3><p><strong>Não utilizar as diretivas de compilador</strong> <code>#pragma</code>, pois ela é dependente do compilador utilizado. A maioria dos compiladores possuem suporte e um comportamento similar, mas em raros casos isso não é verdade. E é bem quando você precisar entregar o projeto atrasado, que a nova versão de um compilador pode quebrar tudo.</p><p>Esse tipo de abordagem é muito utilizado por programador de C ou programadores muito experientes acostumados com o C++ 98.</p><p>O recomendado é se manter no STL do C++ e usar as funções padrões fornecidas e testadas pelo mundo inteiro.</p><p>Mas nos casos em que é necessário usar o pragma pack, opte por usar o <code>push</code> e o <code>pop</code>.</p><h2 id=aprofundamento>Aprofundamento<a hidden class=anchor aria-hidden=true href=#aprofundamento>#</a></h2><p>A principal referência é o <a href=http://www.catb.org/esr/structure-packing/>The Lost Art of Structure Packing</a>, um guia em inglês que aborda em outras linguagens de programação.</p><p>Também é <a href=https://stackoverflow.com/q/74239354/7690982>possível usar as diretivas</a> <code>#pragma pack(push, n)</code> e <code>#pragma pack(pop)</code>.</p><p>Um <a href=https://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/>artigo no Geek for Geeks</a> é sempre recomendado.</p><h2 id=referências>Referências<a hidden class=anchor aria-hidden=true href=#referências>#</a></h2><ul><li><a href="https://learn.microsoft.com/pt-br/cpp/cpp/alignment-cpp-declarations?view=msvc-170">Alinhamento - Microsoft C++</a></li></ul><ul><li><a href=https://stackoverflow.com/q/4306186/7690982>Structure padding and packing</a></li></ul><ul><li><a href=http://www.catb.org/esr/structure-packing/>The Lost Art of Structure Packing</a></li></ul><ul><li><a href=https://en.cppreference.com/w/cpp/language/alignof>alignof() - Cpp Reference</a></li></ul><ul><li><a href=https://en.cppreference.com/w/cpp/language/alignas>alignas() - Cpp Reference</a></li></ul><ul><li><a href=https://stackoverflow.com/questions/3318410/pragma-pack-effect>#pragma pack effect</a></li></ul><ul><li><a href="https://devblogs.microsoft.com/oldnewthing/20200103-00/?p=103290">Anybody who writes #pragma pack(1) may as well just wear a sign on their forehead that says “I hate RISC”</a></li></ul><ul><li><a href=https://www.geeksforgeeks.org/structure-member-alignment-padding-and-data-packing/>Structure Member Alignment, Padding and Data Packing</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://danieltak.com.br/tags/c++/>C++</a></li><li><a href=https://danieltak.com.br/tags/estrutura/>Estrutura</a></li><li><a href=https://danieltak.com.br/tags/struct/>struct</a></li></ul><nav class=paginav><a class=prev href=https://danieltak.com.br/posts/xml/><span class=title>« Página Anterior</span><br><span>XML parser</span>
</a><a class=next href=https://danieltak.com.br/posts/ola-mundo/><span class=title>Próxima Página »</span><br><span>Olá Mundo!</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Alinhamento, Preenchimento e Empacotamento de Estruturas de Dados on x" href="https://x.com/intent/tweet/?text=Alinhamento%2c%20Preenchimento%20e%20Empacotamento%20de%20Estruturas%20de%20Dados&amp;url=https%3a%2f%2fdanieltak.com.br%2fposts%2falinhamento-estrutura%2f&amp;hashtags=C%2b%2b%2cEstrutura%2cstruct"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Alinhamento, Preenchimento e Empacotamento de Estruturas de Dados on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fdanieltak.com.br%2fposts%2falinhamento-estrutura%2f&amp;title=Alinhamento%2c%20Preenchimento%20e%20Empacotamento%20de%20Estruturas%20de%20Dados&amp;summary=Alinhamento%2c%20Preenchimento%20e%20Empacotamento%20de%20Estruturas%20de%20Dados&amp;source=https%3a%2f%2fdanieltak.com.br%2fposts%2falinhamento-estrutura%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Alinhamento, Preenchimento e Empacotamento de Estruturas de Dados on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fdanieltak.com.br%2fposts%2falinhamento-estrutura%2f&title=Alinhamento%2c%20Preenchimento%20e%20Empacotamento%20de%20Estruturas%20de%20Dados"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Alinhamento, Preenchimento e Empacotamento de Estruturas de Dados on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fdanieltak.com.br%2fposts%2falinhamento-estrutura%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Alinhamento, Preenchimento e Empacotamento de Estruturas de Dados on whatsapp" href="https://api.whatsapp.com/send?text=Alinhamento%2c%20Preenchimento%20e%20Empacotamento%20de%20Estruturas%20de%20Dados%20-%20https%3a%2f%2fdanieltak.com.br%2fposts%2falinhamento-estrutura%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Alinhamento, Preenchimento e Empacotamento de Estruturas de Dados on telegram" href="https://telegram.me/share/url?text=Alinhamento%2c%20Preenchimento%20e%20Empacotamento%20de%20Estruturas%20de%20Dados&amp;url=https%3a%2f%2fdanieltak.com.br%2fposts%2falinhamento-estrutura%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Alinhamento, Preenchimento e Empacotamento de Estruturas de Dados on ycombinator" href="https://news.ycombinator.com/submitlink?t=Alinhamento%2c%20Preenchimento%20e%20Empacotamento%20de%20Estruturas%20de%20Dados&u=https%3a%2f%2fdanieltak.com.br%2fposts%2falinhamento-estrutura%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://danieltak.com.br>danieltak</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>